<pre style='background-color:blue;'>
<font color='blue'>
package search.search;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.Stack;

public class Topological {
	
	private int vertices;
    private LinkedList&lt;Integer&gt; adj[];
	
	Topological(Graph g) {
		vertices = g.getVertices();
		adj = g.getAdjacencyList();
	}

    
    void topologicalSortUtil(int v, boolean visited[],
                             Stack&lt;Integer&gt; stack)
    {
        
        visited[v] = true;
        Integer i;
 
        
        
        Iterator&lt;Integer&gt; it = adj[v].iterator();
        while (it.hasNext())
        {
            i = it.next();
            if (!visited[i])
                topologicalSortUtil(i, visited, stack);
        }
 
        
        stack.push(new Integer(v));
    }
 
    
    
    public void topologicalSort()
    {
        Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();
 
        
        boolean visited[] = new boolean[vertices];
        for (int i = 0; i &lt; vertices; i++)
            <font color='#ff0000' weight='1' id='421'><font color='#000eff' weight='0.0138889' id='410'>visited</font><font color='#0038ff' weight='0.0555556' id='415'>[<font color='#0007ff' weight='0.00694444' id='412'>i</font>]</font> <font color='#001cff' weight='0.0277778' id='418'>= </font><font color='#001cff' weight='0.0277778' id='420'>false</font>;</font>
 
        
        
        
        for (int i = 0; i &lt; vertices; i++)
            if (visited[i] == false)
                topologicalSortUtil(i, visited, stack);
 
        
        while (stack.empty()==false)
            System.out.print(stack.pop() + " ");
    }
}
</font>
</pre>
<pre style='background-color:blue;'>
<font color='blue'>
  private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) {

        
        assert isSorted(a, lo, mid);
        assert isSorted(a, mid+1, hi);

        
        for (int k = lo; k &lt;= hi; k++) {
            aux[k] = a[k]; 
        }

        
        int i = lo, j = mid+1;
        for (int k = lo; k &lt;= hi; k++) {
            if      (i &gt; mid)              a[k] = aux[j++];   
            else if (j &gt; hi)               a[k] = aux[i++];
            else if (<font color='#ff2800' weight='0.96' id='297'><font color='#0014ff' weight='0.02' id='274'>less</font><font color='#00ff51' weight='0.42' id='296'>(<font color='#003dff' weight='0.06' id='284'><font color='#0036ff' weight='0.0533333' id='283'><font color='#002fff' weight='0.0466667' id='282'><font color='#0003ff' weight='0.00333333' id='276'>aux</font><font color='#000dff' weight='0.0133333' id='281'>[<font color='#0003ff' weight='0.00333333' id='279'><font color='#0001ff' weight='0.00166667' id='278'>j</font>]</font></font></font></font>, </font><font color='#003dff' weight='0.06' id='294'><font color='#0036ff' weight='0.0533333' id='293'>aux[i]</font>)</font></font></font>) a[k] = aux[j++];
            else                           a[k] = aux[i++];
        }

        
        assert isSorted(a, lo, hi);
    }

    
    private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) {
        if (hi &lt;= lo) return;
        int mid = lo + (hi - lo) / 2;
        sort(a, aux, lo, mid);
        sort(a, aux, mid + 1, hi);
        merge(a, aux, lo, mid, hi);
    }

    
    public static void sort(Comparable[] a) {
        Comparable[] aux = new Comparable[a.length];
        sort(a, aux, 0, a.length-1);
        assert isSorted(a);
    }
</font>
</pre>

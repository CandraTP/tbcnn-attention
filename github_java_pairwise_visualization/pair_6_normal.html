Highlighting both left and right by computing their weighted differences
n = 1
<pre style='background-color:blue;'>
<font color='blue'>
  public static void quicksort(int[] a, int start, int end) {
        if (start &gt;= end)
            return;

        int pavot = a[start];
        int i = start;
        int j = end;

        while (i &lt; j) {
            while (i &lt; j &amp;&amp; a[j] &gt; pavot)
                j--;
            while (i &lt; j &amp;&amp; a[i] &lt;= pavot)
                i++;
            if (i != j) {
                int t = a[i];
                a[i] = a[j];
                a[j] = t;
            }
        }
        if (i == j) {
            int t = a[start];
            a[start] = a[i];
            a[j] = t;
        }
        quicksort(a, start, i - 1);
        quicksort(a, i + 1, end);
    }</font>
</pre>
n = 1
<pre style='background-color:blue;'>
<font color='blue'>
public static int partition(int arr[], int low, int high)
 {
     int pivot = arr[high]; 
     int i = (low-1); 
     for (int j=low; j&lt;high; j++)
     {
         
         
         if (arr[j] &lt;= pivot)
         {
             i++;

             
             int temp = arr[i];
             arr[i] = arr[j];
             arr[j] = temp;
         }
     }

     
     int temp = arr[i+1];
     arr[i+1] = arr[high];
     arr[high] = temp;

     return i+1;
 }


 
 public static void sort(int arr[], int low, int high)
 {
     if (low &lt; high)
     {
         
         int pi = partition(arr, low, high);

         
         
         sort(arr, low, pi-1);
         sort(arr, pi+1, high);
     }
 }

 </font>
</pre>

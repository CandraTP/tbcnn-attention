<pre style='background-color:blue;'>
<font color='blue'>
 public static void sort(Comparable[] a){
        int N = a.length;               
        int h = 1;                      
        while(h &lt; N / 3) h = 3*h + 1;   
        while(h &gt;= 1){                  
            for(int i = h; i &lt; N; i++){
                
                for(int j = i; j &gt;= h &amp;&amp; less(a[j], a[j - h]); j-= h)
                    exch(a, j, j - h);
            } 
            h = h / 3;                  
        }                              
    }
    
    
    
    
    
    
    public static boolean less(Comparable v, Comparable w)
    {    <font color='#ff0000' weight='1' id='276'>return <font color='#ff0000' weight='1' id='274'><font color='#ff0000' weight='1' id='269'><font color='#ff0000' weight='1' id='262'><font color='#ff0000' weight='1' id='257'>v</font>.<font color='#ff0000' weight='1' id='261'>compareTo</font></font><font color='#ff0000' weight='1' id='268'>(<font color='#ff0000' weight='1' id='266'><font color='#ff0000' weight='1' id='265'>w</font>)</font></font> </font><font color='#ff0000' weight='1' id='271'>&lt;<font color='#ff0000' weight='1' id='270'></font> </font><font color='#ff0000' weight='1' id='273'>0<font color='#ff0000' weight='1' id='272'></font></font>;</font> }</font><font color='#ff0000' weight='1' id='277'></font>
    
    
    private static void exch(Comparable[] a, int i, int j){
        Comparable swap = a[i];
        a[i] = a[j];
        a[j] = swap;
    }</font>
</pre>
<pre style='background-color:blue;'>
<font color='blue'>

package org.hibernate.envers.internal.tools.graph;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;


public class TopologicalSort&lt;R&gt; {
	private List&lt;R&gt; sorted;
	private int time;

	private void process(Vertex&lt;R&gt; v) {
		if ( v.getStartTime() != 0 ) {
			
			return;
		}

		v.setStartTime( time++ );

		for ( Vertex&lt;R&gt; n : v.getNeighbours() ) {
			process( n );
		}

		v.setEndTime( time++ );

		sorted.add( v.getRepresentation() );
	}

	public List&lt;R&gt; sort(Collection&lt;Vertex&lt;R&gt;&gt; vertices) {
		sorted = new ArrayList&lt;&gt;( vertices.size() );

		time = 1;

		for ( Vertex&lt;R&gt; v : vertices ) {
			if ( v.getEndTime() == 0 ) {
				process( v );
			}
		}

		Collections.reverse( sorted );

		return sorted;
	}
}
</font>
</pre>
